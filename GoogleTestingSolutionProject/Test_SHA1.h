#ifndef TEST_SHA1_H
#define TEST_SHA1_H

#include "../SHA1_Hash/SHA1.h"
#include "gtest/gtest.h"
#include "gmock/gmock.h"
#include <string>

/*Unit Test Rijndael Algorithm*/

class SHA1Test : public ::testing::Test {
public:
	SHA1* rInstance{ nullptr };

protected:
	void SetUp() override {
		rInstance = new SHA1;
	}

	void TearDown() override { delete rInstance; }
};

TEST_F(SHA1Test, CorrectWorkFunctionPreprocessing) {
	vector<uint8_t> CorrectLastBlock{ 'a','b','c',0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18 };
	vector<uint8_t>* _Message = new vector<uint8_t>{ 'a','b','c' };
	rInstance->byarrMessage = _Message;
	rInstance->Preprocessing();

	ASSERT_EQ(CorrectLastBlock.size(), 64);
	ASSERT_EQ(_Message->size(), 64);
	for (uint8_t i = 0; i < 64; i++) { EXPECT_EQ(CorrectLastBlock[i], (*_Message)[i]); };

};

TEST_F(SHA1Test, CorrectWorkFunctionPaddingTheMessage) {
	vector<uint8_t> CorrectLastBlock{ 'a','b','c',0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18 };
	vector<uint8_t>* _Message = new vector<uint8_t>{ 'a','b','c' };
	rInstance->byarrMessage = _Message;
	rInstance->PaddingTheMessage();

	ASSERT_EQ(CorrectLastBlock.size(), 64);
	ASSERT_EQ(_Message->size(), 64);
	for (uint8_t i = 0; i < 64; i++) { EXPECT_EQ(CorrectLastBlock[i], (*_Message)[i]); };

};

TEST_F(SHA1Test, CorrectWorkFunctionGetHash) {
	vector<uint8_t> CorrectDigest{ 0xa9, 0x99, 0x3e, 0x36, 0x47, 0x06, 0x81, 0x6a, 0xba, 0x3e, 0x25, 0x71, 0x78, 0x50, 0xc2, 0x6c, 0x9c, 0xd0, 0xd8, 0x9d };
	vector<uint8_t>* SendMessage = new vector<uint8_t>{ 'a','b','c' };
	auto Digest = rInstance->GetHash(SendMessage);

	ASSERT_EQ(CorrectDigest.size(), 20);
	ASSERT_EQ(Digest->size(), 20);

	for (uint8_t i = 0; i < 20; i++) { EXPECT_EQ(CorrectDigest[i], (*Digest)[i]); };
};

#endif // TEST_SHA1_H
