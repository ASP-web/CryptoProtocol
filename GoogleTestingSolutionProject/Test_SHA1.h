#ifndef TEST_SHA1_H
#define TEST_SHA1_H

#include "../SHA1_Hash/SHA1.h"
#include "gtest/gtest.h"
#include "gmock/gmock.h"

/*Unit Test Rijndael Algorithm*/

class SHA1Test : public ::testing::Test {
public:
	SHA1* rInstance{ nullptr };

protected:
	void SetUp() override {
		rInstance = new SHA1;
	}

	void TearDown() override { delete rInstance; }
};

TEST_F(SHA1Test, CorrectWorkFunctionPaddingTheMessage) {
	vector<uint8_t> CorrectLastBlock{ 'a','b','c',0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18 };
	vector<uint8_t>* _Message = new vector<uint8_t>{ 'a','b','c' };
	rInstance->byarrMessage = _Message;
	rInstance->PaddingTheMessage();

	ASSERT_EQ(CorrectLastBlock.size(), 64);
	ASSERT_EQ(_Message->size(), 64);
	for (uint8_t i = 0; i < 64; i++) { EXPECT_EQ(CorrectLastBlock[i], (*_Message)[i]); };

};


#endif // TEST_SHA1_H
